//
//  ViewController.m
//  ProjectEuler
//
//  Created by Nina on 04/03/15.
//  Copyright (c) 2015 Learn. All rights reserved.
//

#import "ViewController.h"
#import "NSArray+RangeArray.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib
    [self.view setBackgroundColor:[UIColor whiteColor]];
}

- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    [self primeNumberAtPosition];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

#pragma mark - Problem #1
//If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
//Find the sum of all the multiples of 3 or 5 below 1000.
- (void)getTotalOfNumbersDividibleBy3n5 {
    
    NSArray * numbers = [NSArray arrayWithNumbersInRange:NSMakeRange(0, 999)];
    int total = 0;
    for( NSNumber * number in numbers ){
        int no = [number unsignedIntValue];
        if ((no % 3 == 0) || (no % 5 == 0)) {
            total += no;
        }
    }
    NSLog(@"%i",total);
}

#pragma mark - Problem #2
/*Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.*/
- (void)fibonacciAdditionOfEvenValued {//4613732
    
    int fib1 = 1;
    int fib2 = 1;
    int result = 0;
    int summed = 0;
    
    while (result < 4000000) {
        if ((result % 2) == 0) {
            summed += result;
        }
        
        result = fib1 + fib2;
        fib2 = fib1;
        fib1 = result;
    }
    NSLog(@"summed %i", summed);
}

#pragma mark - Problem #3
/* The prime factors of 13195 are 5, 7, 13 and 29.
 What is the largest prime factor of the number 600851475143 ?*/
- (void)primeNumber {//6857

    int result;
    long input = 600851475143;
    
    for (result = 2; result < input; result ++) {
        if (input % result == 0) { //if the value is dividable by result, divide it to continue
            input /= result; //Neglect the divided value
            result --;
        }
    }
    NSLog(@"result %i", result);
}

#pragma mark - Problem #4
/* A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
 Find the largest palindrome made from the product of two 3-digit numbers.*/
- (void)largestPalindrome {//906609
    
    int largest = 0;
    int smallest = 999999;
    
    NSArray * numbers   =   [NSArray arrayWithNumbersInRange:NSMakeRange(100, 899)];
    
    for (int i = (int)numbers.count - 1; i >= 0; i --) {//Issue? will it multiply with itself?
        for (int j = (int)numbers.count - 1; j >= 0; j--) {
            int a = [numbers[i] intValue];
            int b = [numbers[j] intValue];
            int mul = a * b;
            
            //Ref: http://stackoverflow.com/questions/17946649/check-if-string-is-palindrome-in-objective-c
            NSString *p = [NSString stringWithFormat:@"%i", mul];
            NSInteger length = p.length;
            
            NSInteger halfLength = length / 2;
            
            __block BOOL isPalindrome = YES;
            
            [p enumerateSubstringsInRange:NSMakeRange(0, halfLength) options:NSStringEnumerationByComposedCharacterSequences usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) {
                NSRange otherRange = [p rangeOfComposedCharacterSequenceAtIndex:length - enclosingRange.location - 1];
                
                if (![substring isEqualToString:[p substringWithRange:otherRange]]) {
                    isPalindrome = NO;
                    *stop = YES;
                }
            }];
            if (isPalindrome) {
                if ([p intValue] > largest) {
                    largest = [p intValue];
                }
                if ([p intValue] < smallest) {
                    smallest = [p intValue];
                }
            }
        }
    }
    NSLog(@"largest = %i & smallest = %i", largest, smallest);
}

#pragma mark - Problem #5
/*2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
 What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?*/
- (void)smallestDivider {//232792560
    
    NSArray * numbers   =   [NSArray arrayWithNumbersInRange:NSMakeRange(1, 19)];
    NSNumber *sum       =   [numbers valueForKeyPath:@"@sum.self"];
    double maxLimit     =   pow([sum doubleValue], 20.0);
    
    for (int limit = 20; limit <= maxLimit; limit ++) {
        int modulo = 0;
        for (NSNumber *divider in numbers) {
            modulo  +=  limit % [divider intValue];
        }
        if (modulo == 0) {
            NSLog(@"Result %i", limit);
            break;
        }
    }
}

#pragma mark - Problem #6
/* The sum of the squares of the first ten natural numbers is,
 12 + 22 + ... + 102 = 385
 The square of the sum of the first ten natural numbers is,
 (1 + 2 + ... + 10)2 = 552 = 3025
 Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
 Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
*/
- (void)squareDifference {//25164150

    NSArray * numbers   =   [NSArray arrayWithNumbersInRange:NSMakeRange(1, 99)];
    NSNumber *sum       =   [numbers valueForKeyPath:@"@sum.self"];
    double sumSquare    =   pow([sum doubleValue], 2.0);
    
    NSArray *squaredNumbers =   [NSArray arrayWithSquaredNumbersInRange:NSMakeRange(1, 99)];
    NSNumber    *squaredSum =   [squaredNumbers valueForKeyPath:@"@sum.self"];
    
    double difference  =   sumSquare - [squaredSum doubleValue];
    NSLog(@"difference %.0f", difference);
}

#pragma mark - Problem #7
/* By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
 What is the 10001st prime number?
*/
- (void)primeNumberAtPosition {//104743
    
    NSInteger maxLimit              =   10001;
    NSMutableArray *primeNumbers    =   [NSMutableArray arrayWithCapacity:maxLimit];
    int i = 2; //smallest palindrome
    BOOL isPrime;
    int divi = 2;
    
    do {
        isPrime = YES;
        for (divi = 2; divi < i; divi++) {
            if (i % divi == 0) {
                isPrime = NO;
                continue;
            }
        }
        if (isPrime)
            [primeNumbers addObject:[NSNumber numberWithInt:i]];
        i++;

    } while ([primeNumbers count] < maxLimit);
    NSLog(@"%lu-st prime number %i", (unsigned long)primeNumbers.count, [[primeNumbers lastObject] intValue]);
}

@end
